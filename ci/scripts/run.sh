#!/usr/bin/env bash
#
# Copyright (c) The Bitcoin Core developers
# Distributed under the MIT software license, see the accompanying
# file COPYING or http://www.opensource.org/licenses/mit-license.php.

export LC_ALL=C.UTF-8

set -o errexit -o nounset -o pipefail -o xtrace

echo "::group::Enable core dumps"

# Try to ensure cores are written as files (not to systemd-coredump/apport).
# This typically requires root; it's okay if it fails â€” we'll fall back to coredumpctl.
want_pattern='core.%e.%p.%t'
have_sudo=0
if command -v sudo >/dev/null 2>&1; then have_sudo=1; fi
if [[ -r /proc/sys/kernel/core_pattern ]]; then
  current="$(cat /proc/sys/kernel/core_pattern || true)"
  if [[ "$current" == '|'* ]]; then
    # Piped to a handler; try to switch to file-based cores
    if (( have_sudo )); then sudo sysctl -w "kernel.core_pattern=$want_pattern" || true; fi
  else
    # Already file-based; try to make the name more informative
    if (( have_sudo )); then sudo sysctl -w "kernel.core_pattern=$want_pattern" || true; fi
  fi
fi

echo "core_pattern now: $(cat /proc/sys/kernel/core_pattern 2>/dev/null || echo '?')"
echo "::endgroup::"

[ "${CI_CONFIG+x}" ] && source "$CI_CONFIG"

status=0
if ! nix-shell --pure --keep CI_CONFIG --keep CI_CLEAN "${NIX_ARGS[@]+"${NIX_ARGS[@]}"}" --run ci/scripts/ci.sh shell.nix; then
  status=$?
  echo "ci.sh failed with status $status"
fi

# --- Collect core files (file-based) -----------------------------------------
echo "::group::Search for core files"
mapfile -t cores < <(find "${GITHUB_WORKSPACE:-$PWD}" -xdev \
  \( -type f -name 'core' -o -name 'core.*' \) 2>/dev/null || true)
echo "Found ${#cores[@]} possible core files."
echo "::endgroup::"

# --- If no file-based cores, try systemd-coredump (Ubuntu) -------------------
use_coredumpctl=0
if [[ "${#cores[@]}" -eq 0 ]] && command -v coredumpctl >/dev/null 2>&1; then
  # List recent dumps for this workspace's binaries (best-effort heuristic).
  # If you know the test binary name(s), set EXE_HINT to narrow it.
  EXE_HINT="mptest"
  echo "::group::Check systemd-coredump"
  if [[ -n "$EXE_HINT" ]]; then
    coredumpctl --no-pager list | grep -E "$EXE_HINT" || true
  else
    coredumpctl --no-pager list | head -n 50 || true
  fi
  echo "::endgroup::"
  use_coredumpctl=1
fi

# --- Print backtraces --------------------------------------------------------
echo "::group::Backtraces"

backtrace_with_gdb () {
  local exe="$1" core="$2"
  if [[ -n "$exe" && -x "$exe" ]]; then
    echo "Core: $core"
    echo "Exe:  $exe"
    gdb -batch "$exe" "$core" \
      -ex 'set pagination off' \
      -ex 'set print pretty on' \
      -ex 'info threads' \
      -ex 'thread apply all bt full' \
      -ex 'quit' || true
  else
    echo "Core: $core (exe unknown or not executable; trying core-only mode)"
    gdb -batch -c "$core" \
      -ex 'set pagination off' \
      -ex 'set print pretty on' \
      -ex 'info threads' \
      -ex 'info files' \
      -ex 'thread apply all bt full' \
      -ex 'quit' || true
  fi
}
if [[ "${#cores[@]}" -gt 0 ]]; then
  for core in "${cores[@]}"; do
    # Try to extract the executable path that gdb discovers from the core
    exe="$(gdb -batch -c "$core" -ex 'info files' 2>/dev/null | sed -n "s/^Core was generated by \`\(.*\)'.*$/\1/p" | head -n1 || true)"
    backtrace_with_gdb "$exe" "$core"
  done
elif (( use_coredumpctl )); then
  # If your tests produce a known binary name, set EXE_HINT to make this precise.
  # Otherwise we grab the newest C/C++ dump and use that.
  line="$(coredumpctl --no-pager --no-legend list | tail -n 1)"
  if [[ -n "$EXE_HINT" ]]; then
    line="$(coredumpctl --no-pager --no-legend list | grep -E "$EXE_HINT" | tail -n 1 || true)"
  fi
  if [[ -n "$line" ]]; then
    pid="$(awk '{print $5}' <<<"$line" || true)"
    exe_path="$(coredumpctl --no-pager info "$pid" \
             | sed -n 's/^ *Executable: //p' \
             | head -n1)"
    # Dump that core to a file and analyze
    out="core.from-coredumpctl.${pid:-unknown}"
    if coredumpctl dump "${pid:-}" -o "$out" >/dev/null 2>&1; then
      backtrace_with_gdb "$exe_path" "$out"
    else
      echo "Could not dump core via coredumpctl (pid=$pid)."
      # As a last resort, coredumpctl can drive gdb directly, but it's interactive.
      # We avoid that in CI.
    fi
    rm -v "$out"
  else
    echo "No matching coredumps in systemd-coredump."
  fi
else
  echo "No core files found."
fi

echo "::endgroup::"

# Preserve the original test result code
exit "$status"
